/*
 * driver_uart.c
 *
 *  Created on: Apr 21, 2024
 *      Author: benjaminowen
 */

#include "string.h"

#include "usart.h"

#include "driver_uart.h"

#define UART_BUF_LENGTH	80

char uart_send_buf[UART_BUF_LENGTH];	// buffer for messages to send over UART
char uart2_recv_buf[UART_BUF_LENGTH];	// buffer for messages received over UART2
char uart4_recv_buf[UART_BUF_LENGTH];	// buffer for messages received over UART4
uint8_t uart2_recv_buf_tail;			// location of next empty byte in recv buffer
uint8_t uart4_recv_buf_tail;			// location of next empty byte in recv buffer

// function to initialize UART driver
void Driver_UART_Init()
{
	// default variable values
	uart2_recv_buf_tail = 0;
	uart4_recv_buf_tail = 0;
	uart2_recv_buf[3] = "\r";
	uart2_recv_buf[4] = "\n";
	uart4_recv_buf[3] = "\r";
	uart4_recv_buf[4] = "\n";
	// start listening for interrupts
	HAL_UART_Receive_DMA(&huart2, (unsigned char *) uart2_recv_buf, 1);
	HAL_UART_Receive_DMA(&huart4,  (unsigned char *) uart4_recv_buf, 3);
	// "hello" message
	Driver_UART_Transmit(NUCLEO, "\e[2J\e[HAMP Kart UART Interface\r\n=======================\r\n");
}

// function to send a string message over UART
void Driver_UART_Transmit(UART_Location_T dest, char * message)
{
	// send to correct destination
	if (dest == NUCLEO)
	{
		if (message == NULL)
		{
			// place buffer into message
			strncpy(uart_send_buf, uart2_recv_buf, uart2_recv_buf_tail);
			// send
			HAL_UART_Transmit_DMA(&huart2, (unsigned char *) uart_send_buf, uart2_recv_buf_tail);
			HAL_UART_Transmit_DMA(&huart2, (unsigned char *) "\r\n", 2);
		}
		else
		{
			// copy message into buffer
			strcpy(uart_send_buf, message);
			// send
			HAL_UART_Transmit_DMA(&huart2, (unsigned char *) uart_send_buf, strlen(uart_send_buf));
		}
	}
	else if (dest == JETSON)
	{
		if (message == NULL)
		{
			// place buffer into message
			strncpy(uart_send_buf, uart4_recv_buf, 3);
			// send
			HAL_UART_Transmit_DMA(&huart4, (unsigned char *) uart_send_buf, 5);
//			HAL_UART_Transmit_DMA(&huart4, (unsigned char *) "\r\n", 2);
		}
		else
		{
			// copy message into buffer
			strcpy(uart_send_buf, message);
			// send
			HAL_UART_Transmit_DMA(&huart4, (unsigned char *) uart_send_buf, strlen(uart_send_buf));
		}
	}
}

// function to get char buffer
unsigned char * Driver_UART_GetBuffer(UART_Location_T src)
{
	if (src == NUCLEO)
	{
		return (unsigned char *) uart2_recv_buf;
	}
	else if (src == JETSON)
	{
		return (unsigned char *) uart4_recv_buf;
	}

	// error condition
	return NULL;
}

//// function to place byte into buffer (typically from interrupt)
//uint8_t Driver_UART_PushByte(UART_Location_T src, char byte)
//{
//	// place byte into buffer and increment tail variable
//	if (src == NUCLEO)
//	{
//		uart2_recv_buf[recv_buf_tail2++] = byte;
//	}
//	else if (src == JETSON)
//	{
//		uart4_recv_buf[recv_buf_tail4++] = byte;
//	}
//
//	// check if potential buffer overflow
//	if (uart2_recv_buf_tail >= UART_BUF_LENGTH)
//	{
//		// prevent overflowing buffer
//		uart2_recv_buf_tail = UART_BUF_LENGTH - 1;
//		// send error message to debug UART interface
//		Driver_UART_Transmit(NUCLEO, "UART2 recv buffer overflow!\r\n");
//		// return error code
//		return 1;
//	}
//	else if (uart4_recv_buf_tail >= UART_BUF_LENGTH)
//	{
//		// prevent overflowing buffer
//		uart4_recv_buf_tail = UART_BUF_LENGTH - 1;
//		// send error message to debug UART interface
//		Driver_UART_Transmit(NUCLEO, "UART4 recv buffer overflow!\r\n");
//		// return error code
//		return 1;
//	}
//
//	return 0;
//}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	HAL_UART_Receive_DMA(&huart4,  (unsigned char *) uart4_recv_buf, 3);
}
